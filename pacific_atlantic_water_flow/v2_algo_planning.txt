0. Create a matrix of the same size as input named flow_destinations and initialize each cell with {"Pacific": False, "Atlantic": False}.
1. Sort the matrix, in a stable manner, into lowest to highest value.

2. Work the sorted array in order from lowest to highest and:
  a. Working Left -> Up -> Right -> Down
    1. check the corresponding flow_destinations cell for the cell in that coordinate. 
    2. If flow_destinations contains {"Pacific": True, "Atlantic": True}, set the current cell's flow_destination cell to {"Pacific": True, "Atlantic": True} and exit the 2a loop.
    3. If the cell's value is lower than the curent_cell's value, forward its flow destinations value to the current_cell's values.
    4. If flow_destinations does not contain {"Pacific": True, "Atlantic": True}, and current_recursive_stack does not contain the new_position, add the current cell to current_recursive_stack, recurse to the new_position cell starting at 2a.
  b. Set the current cell's flow_destinations to whatever is returned by the recursive stack
End

Next Step -> Hand Test this variant of the algo since it's different from the two previous hand tests.

NOTES
* It might be possible to optimize by setting the edge cell values in Step 0 to the known adjacency values. e.g. top right cell is {"Pacific": True, "Atlantic": True}.
* The merging of flow_destinations needs a special function to ensure we can only ever move from false to true and never from true to false for a given value. This might be worth an object to make the code cleaner.